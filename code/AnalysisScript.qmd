---
title: "The Greatest eDNA Study Ever"
author: "FHL 2025 eDNA Workshop"
format: html
editor: visual
---

```{r Preliminary}
#| include: false
#| echo: false

#Set up here: load data and quality control
library(tidyverse)
library(here)
library(vegan)
library(readxl)
#library(microViz)
library(lubridate)
#library(pairwiseAdonis)               
here::i_am("FHL_2025_eDNA.Rproj")
# Set working directory
setwd(here())

###create functions
#Function for calculating the eDNA Index from Kelly et al. 2019
eDNA_index <- function(community_matrix){
  #community matrix with samples in cols, species in rows
  require(vegan)
  
  props <- decostand(community_matrix, method = "total", MARGIN = 2)
  
  idx <- decostand(props, method = "max", MARGIN = 1)
  idx <- as.data.frame(idx)
  colnames(idx) <- colnames(community_matrix)
  row.names(idx) <- row.names(community_matrix)
  
  return(idx)
}

meta <- read.csv(here("data/Field_Data_Sheet_Digitized.csv")) #metadata


###load data: COI
COI_01 <- read.csv(here("data/FHL04_LoLe_taxon_table_wide.csv")) #raw data

###load data: MV1
MV1_01 <- read.csv(here("data/FHL02_MV1_taxon_table_wide.csv")) #raw data

###load data: MFU
MFU_01 <- read.csv(here("data/FHL03_MFU_taxon_table_wide.csv")) #raw data

```

```{r}
#MicroDecon on COI ASV table

# Load Dependencies

# Check if devtools is installed--needed to install microDecon
if (!requireNamespace("devtools", quietly = TRUE)) {
  install.packages("devtools")
}

# Load devtools
library(devtools)

# Check if microDecon is installed
if (!requireNamespace("microDecon", quietly = TRUE)) {
  devtools::install_github("donaldtmcknight/microDecon")
}

# Load microDecon
library(microDecon)


# Load ASV Data
COI_ASV_long<-read.csv(here("data/FHL03_LoLe_ASV_table.csv"))

Neg_IDs<-read.csv(here("data/Negative_controls.csv"))

# Pivot wider for micrDecon
COI_ASV_wide <- COI_ASV_long %>%
  select(Sample_name, Hash, nReads) %>%
  pivot_wider(
    names_from = Sample_name,
    values_from = nReads,
    values_fill = 0
  )

COI_wide_reordered <- {
  
  # Step 1: Map ordered labels to matching columns
  neg_cols_ordered_full <- Neg_IDs %>%
    arrange(Control_stage) %>%
    pull(Label) %>%
    # For each label, get all COI_wide columns that contain it
    lapply(function(x) colnames(COI_ASV_wide)[str_detect(colnames(COI_ASV_wide), fixed(x))]) %>%
    unlist()
  
 # Reorder: Hash first, then neg cols, then everything else
  COI_ASV_wide %>%
    select(Hash,
           all_of(neg_cols_ordered_full),
           setdiff(colnames(.), c("Hash", neg_cols_ordered_full)))
}

#Add FHL0 or FHL00 before tube number for easier string identification
meta_rn <- meta %>%
  mutate(
    Tube.Number = ifelse(
      nchar(as.character(Tube.Number)) == 2,
      paste0("FHL0", Tube.Number),   # already two digits → FHL0xx
      paste0("FHL00", Tube.Number)   # one digit → FHL00x
    )
  )

#Need to create a biological replicate "group" column (combine Data_Day.Night_Treatment)
meta_rn <- meta_rn %>%
  
  mutate(group = paste(Date, Day.Night, Treatment..Light..NoLight..FieldNegative., sep = "_"))


#Get ordered groups of sample information

#Order Tube.Number by group only for samples
tube_order_sam <- meta_rn %>%
  filter(Treatment..Light..NoLight..FieldNegative. !="FieldNegative")%>%
  arrange(group) %>%        # order by group
  pull(Tube.Number)

# For each tube number of the sample, find matching columns in COI_wide_ordered (some tubes numbers may be missing after sequencing run due to filtering of low quality reads)
matched_cols <- unlist(lapply(tube_order_sam, function(tn) {
  grep(tn, colnames(COI_wide_reordered), value = TRUE)
}))

# Reorder COI_wide_ordered
COI_wide_grouped <- COI_wide_reordered %>%
  select(all_of(matched_cols))

# Keep only matched rows from Meta for counting how many reps are in each group left in our final data
Meta_sub <- meta_rn %>%
  filter(Tube.Number %in% str_extract(colnames(COI_wide_grouped), paste(Tube.Number, collapse = "|")))

# Count samples per groups that made it to final seq data
sample_counts <- Meta_sub %>%
  group_by(group) %>%
  summarise(sample_count = n())


#Combine back with Neg controls and put at the beginning, do not need c
COI_for_decon<-cbind(COI_wide_reordered[,c(1:13)],COI_wide_grouped)#12 negative controls

# First group is assumed to be the blanks (e.g., "negative controls")
num.blanks <- as.numeric(length(Neg_IDs$Name))

# The rest are the replicate counts per group
numb.ind <- as.numeric(sample_counts$sample_count)

#make sure ASV table is a dataframe
COI_for_decon<-as.data.frame(COI_for_decon)

#check that first column is character and others are integers/numeric
str(COI_for_decon)
column_sums<-colSums(COI_for_decon[,2:ncol(COI_for_decon)])#check if any sums are zero if so need to remove

#Run microDecon, Hash first column, followed by blanks, then grouped samples
COI_decon_output <- decon(
  COI_for_decon,
  num.blanks,
  numb.ind, 
  taxa=FALSE
)

# Pull out the decontaminated df
COI_decon_output_df<-COI_decon_output[["decon.table"]]

# Pull out the df of reads that were removed
COI_removed_taxa<-COI_decon_output[["reads.removed"]]

COI_decon_long <- COI_decon_output_df %>%
  # Remove the Mean.blank column
  select(-Mean.blank) %>%
  # Pivot all columns except Hash
  pivot_longer(
    cols = -Hash,
    names_to = "Sample_name",
    values_to = "nReads"
  ) %>%
  #Add Label column to match original dataset
  mutate(Label="LoLe") %>% 
  relocate(Sample_name, .before = "Hash") %>% 
  relocate(Label, .after = "Sample_name")    # move it after column Hash


COI_removed_long <- COI_removed_taxa %>%
  # Remove the Mean.blank column
  select(-Mean.blank) %>%
  # Pivot all columns except Hash
  pivot_longer(
    cols = -Hash,
    names_to = "Sample_name",
    values_to = "nReads"
  )


write.csv(COI_decon_output_df, here("data/COI_ASV_decon_wide.csv"))
write.csv(COI_removed_taxa, here("data/COI_removed_ASVs.csv"))
write.csv(COI_decon_long, here("data/FHL03_LoLe_microDecon_ASV_table.csv"),row.names = FALSE)
write.csv(COI_removed_long,here("data/COI_removed_ASVs_long.csv"),row.names = FALSE)


COI_01  <- read.csv(here("data/FHL04_LoLe_taxon_table_wide_MicroDecon.csv")) #raw data
```

```{r QualityControl}

##Quality Control
#First remove the MFU samples that matched barcodes with previous run in the flowcell due to carryover
carryover_samples <- c(
  "FHL094","FHL071","FHL095","FHL078","FHL096",
  "ENC4A","FHL097","ENC5B", "ENC3","FHL021","ENC6C",
  "FHL036","FHL050","PCRNa","FHL064","PCRNb"
)

COI_01 <- COI_01 %>%
  select(!matches(paste(carryover_samples, collapse = "|")))

##here is an example

#QC the raw data for min read depth
COI_02 <- COI_01 %>% 
  dplyr::select(-Class) %>% #Remove Class column
  drop_na() %>% 
  pivot_longer(cols = -BestTaxon) %>% #Make it a long df
  filter(value > 0) %>% #filter out all spcies in samples with no detection
  group_by(BestTaxon) %>% #group by species
  add_tally() %>% #Add count of occurences
  filter(n > 5) %>% ##FILTER for min 5 occurrences
  dplyr::select(-n) %>% #remove the column of occurences 
  pivot_wider(names_from = name, values_from = value, values_fill = 0) %>% #conevrt it back to wide dataframe
  column_to_rownames("BestTaxon") %>% 
  t() %>% 
  as.data.frame() %>% 
  mutate(tot = rowSums(.)) %>% #Compute the total number of reads per sample
  filter(tot > 10000) %>% ##FILTER for total read-depth in sample
  dplyr::select(-tot) %>% #remove the tot reads per sample column
  dplyr::select(which(colSums(.) > 0)) #Filter out all sepcies that have 0 obs in all samples

MV1_02 <- MV1_01 %>% 
  dplyr::select(-2) %>% 
  drop_na() %>% 
  pivot_longer(cols = -BestTaxon) %>% 
  filter(value > 0) %>% 
  group_by(BestTaxon) %>% 
  add_tally() %>% 
  filter(n > 0) %>% ##FILTER for min occurrences
  dplyr::select(-n) %>% 
  pivot_wider(names_from = name, values_from = value, values_fill = 0) %>% 
  column_to_rownames("BestTaxon") %>% 
  t() %>% 
  as.data.frame() %>% 
  mutate(tot = rowSums(.)) %>% 
  filter(tot > 10000) %>% ##FILTER for total read-depth in sample
  dplyr::select(-tot) %>% 
  dplyr::select(which(colSums(.) > 0))

MFU_02 <- MFU_01 %>% 
  dplyr::select(-2) %>% 
  drop_na() %>% 
  pivot_longer(cols = -BestTaxon) %>% 
  filter(value > 0) %>% 
  group_by(BestTaxon) %>% 
  add_tally() %>% 
  filter(n > 5) %>% ##FILTER for min occurrences
  dplyr::select(-n) %>% 
  pivot_wider(names_from = name, values_from = value, values_fill = 0) %>% 
  column_to_rownames("BestTaxon") %>% 
  t() %>% 
  as.data.frame() %>% 
  mutate(tot = rowSums(.)) %>% 
  filter(tot > 10000) %>% ##FILTER for total read-depth in sample
  dplyr::select(-tot) %>% 
  dplyr::select(which(colSums(.) > 0))


#get relevant metadata  
COI_m <- meta %>% 
  dplyr::select(Tube.Number, Date, Time.Finish, Day.Night, Treatment..Light..NoLight..FieldNegative., Temperature, Salinity) %>% 
  rename(Treatment = Treatment..Light..NoLight..FieldNegative.,
         Tube = Tube.Number,
         Time = Time.Finish) %>% 
  mutate(Date = mdy(Date),
         Time = hm(Time)) %>% 
  mutate(datetime = ymd_hms(paste(Date, Time)))

MV1_m <- meta %>% 
  dplyr::select(Tube.Number, Date, Time.Finish, Day.Night, Treatment..Light..NoLight..FieldNegative., Temperature, Salinity) %>% 
  rename(Treatment = Treatment..Light..NoLight..FieldNegative.,
         Tube = Tube.Number,
         Time = Time.Finish) %>% 
  mutate(Date = mdy(Date),
         Time = hm(Time)) %>% 
  mutate(datetime = ymd_hms(paste(Date, Time)))
  
MFU_m <- meta %>% 
  dplyr::select(Tube.Number, Date, Time.Finish, Day.Night, Treatment..Light..NoLight..FieldNegative., Temperature, Salinity) %>% 
  rename(Treatment = Treatment..Light..NoLight..FieldNegative.,
         Tube = Tube.Number,
         Time = Time.Finish) %>% 
  mutate(Date = mdy(Date),
         Time = hm(Time)) %>% 
  mutate(datetime = ymd_hms(paste(Date, Time)))


#make rownames consistent across data and metadata, etc
COI_03 <- COI_02 %>% 
  rownames_to_column("Tube") %>% 
  mutate(Tube = str_replace_all(Tube, pattern = "LoLe\\.FHL", replacement = ""),
         Tube = str_replace_all(Tube, pattern = "\\.COI.+", replacement = "")) %>% 
  mutate(Tube = as.numeric(Tube)) %>% 
  column_to_rownames("Tube")

MV1_03 <- MV1_02 %>% 
  rownames_to_column("Tube") %>% 
  mutate(Tube = str_replace_all(Tube, pattern = "MV1\\.FHL", replacement = ""),
         Tube = str_replace_all(Tube, pattern = "_MV1", replacement = "")) %>% 
  mutate(Tube = as.numeric(Tube)) %>% 
  column_to_rownames("Tube")

MFU_03 <- MFU_02 %>% 
  rownames_to_column("Tube") %>% 
  mutate(Tube = str_replace_all(Tube, pattern = "MFU\\.FHL", replacement = ""),
         Tube = str_replace_all(Tube, pattern = "_MFU+", replacement = "")) %>% 
  mutate(Tube = as.numeric(Tube)) %>% 
  column_to_rownames("Tube")


#filter metadata to just samples we kept after QC
COI_p <- COI_m %>% 
  filter(Tube %in% rownames(COI_03))
  COI_p <- COI_p[order(COI_p$Tube),]
  COI_p <- COI_p %>% 
    unite(c(Date, Day.Night, Treatment), col = tmp, remove = F) %>% 
    mutate(time_idx = match(tmp, unique(tmp)))
  
MV1_p <- MV1_m %>% 
  filter(Tube %in% rownames(MV1_03))
  MV1_p <- MV1_p[order(MV1_p$Tube),]
  MV1_p <- MV1_p %>% 
    unite(c(Date, Day.Night, Treatment), col = tmp, remove = F) %>% 
    mutate(time_idx = match(tmp, unique(tmp)))
  
MFU_p <- MFU_m %>% 
  filter(Tube %in% rownames(MFU_03))
  MFU_p <- MFU_p[order(MFU_p$Tube),]
  MFU_p <- MFU_p %>% 
    unite(c(Date, Day.Night, Treatment), col = tmp, remove = F) %>% 
    mutate(time_idx = match(tmp, unique(tmp)))
  
  
#reorder to mirror metadata
COI_03 <- COI_03[order(as.numeric(rownames(COI_03))),]  
MV1_03 <- MV1_03[order(as.numeric(rownames(MV1_03))),]
MFU_03 <- MFU_03[order(as.numeric(rownames(MFU_03))),]

  
#check ordering
rownames(COI_03) == COI_p$Tube
rownames(MV1_03) == MV1_p$Tube
rownames(MFU_03) == MFU_p$Tube

#remove lab contaminants and NA
contaminants <- c(
  ##Human, pets, and food items
  "Homo sapiens","Homo", "Gorilla",
  "Bos taurus","Bos","Sus scrofa",
  "Canis lupus","Felis catus","Felis",
  "Meleagris gallopavo","Equus caballus",
  "Ovis"
  #Probable water contaminants
)
MV1_04  <- MV1_03  %>%
  select(-any_of(contaminants))
MFU_04  <- MFU_03  %>%
  select(-any_of(contaminants))
COI_04  <- COI_03  %>%
  select(-any_of(contaminants))

##MV1 Annotation curation
MV1_05 <- MV1_04 %>%
  mutate(.row_id = row_number()) %>%
  pivot_longer(-.row_id, names_to = "BestTaxon", values_to = "Reads") %>%
  # missannotated pseudogene
  mutate(BestTaxon = if_else(BestTaxon == "Phocoenoides", "Phocoena phocoena", BestTaxon)) %>%
  # Great blue heron, not the European grey
  mutate(BestTaxon = if_else(BestTaxon == "Ardea cinerea", "Ardea herodias", BestTaxon)) %>%
  # Change to locally occurring sp. in the same genus
  mutate(BestTaxon = if_else(BestTaxon == "Cryptacanthodes maculatus", "Cryptacanthodes aleutensis", BestTaxon)) %>%
  # Genus call is possible
  mutate(BestTaxon = if_else(BestTaxon == "Gadidae", "Gadus", BestTaxon)) %>%
  # Call to only local species in the genus
  mutate(BestTaxon = if_else(BestTaxon == "Hirundo", "Hirundo rustica", BestTaxon)) %>%
  # Unambiguous considering local only
  mutate(BestTaxon = if_else(BestTaxon == "Pholis", "Pholis ornata", BestTaxon)) %>%
  # Change to locally occurring sp. in the same genus
  mutate(BestTaxon = if_else(BestTaxon == "Progne chalybea", "Progne subis", BestTaxon)) %>%
  # Call back to genus due to conflicting annotations
  mutate(BestTaxon = if_else(BestTaxon == "Sebastes mentella", "Sebastes", BestTaxon)) %>%
  group_by(.row_id, BestTaxon) %>%
  summarise(Reads = sum(Reads), .groups = "drop") %>%
  pivot_wider(id_cols = .row_id, names_from = BestTaxon, values_from = Reads, values_fill = 0) %>%
  arrange(.row_id) %>%
  select(-.row_id)


##MFU Annotation curation
MFU_05 <- MFU_04 %>%
  mutate(.row_id = row_number()) %>%
  pivot_longer(-.row_id, names_to = "BestTaxon", values_to = "Reads") %>%
  #Annotation correction for geography
  mutate(BestTaxon = if_else(BestTaxon == "Cryptacanthodes maculatus", "Cryptacanthodes giganteus", BestTaxon)) %>%
    # Call back to genus due to conflicting annotations
  mutate(BestTaxon = if_else(BestTaxon == "Sebastes mentella", "Sebastes", BestTaxon)) %>%
   #Annotation correction for geography
  mutate(BestTaxon = if_else(BestTaxon == "Cryptacanthodes maculatus", "Cryptacanthodes giganteus", BestTaxon)) %>%
  group_by(.row_id, BestTaxon) %>%
  summarise(Reads = sum(Reads), .groups = "drop") %>%
  pivot_wider(id_cols = .row_id, names_from = BestTaxon, values_from = Reads, values_fill = 0) %>%
  arrange(.row_id) %>%
  select(-.row_id)

#check
str(MV1_05)
str(MFU_05)
```

```{r}

```

```{r Transformations}

##COI
    #make pres/absence dataset
    COI_bin = COI_04
      COI_bin[COI_bin>0]<-1  
    
    #make eDNA index dataset
    COI_idx = COI_04 %>%
      t() %>% 
      eDNA_index()
    
    #make proportion dataset  
  
```

```{r NMDS}

### COI 

  ## pres/absence
  dist_coi <- COI_bin %>% 
    vegdist(method = "jaccard", binary = T)
  
  MDS_coi <- dist_coi %>% 
    metaMDS(trymax = 1000)
  
  COI_p %>%
    bind_cols(MDS_coi$points) %>%
    ggplot(aes(x = MDS1, y = MDS2, color = Day.Night, shape = Treatment)) +
    geom_point() +
    stat_chull(aes(fill = Day.Night), alpha = 0.3) +
    theme_minimal()
  
  # permanova
  res <- adonis2(as.matrix(dist_coi) ~ interaction(COI_p$Day.Night,COI_p$Treatment)) 
  res
  
  # posthoc
  pairwise.adonis2(dist_coi ~ MDS_coi, data= COI_p %>% mutate(MDS_coi=paste0(Day.Night,Treatment)), COI_p.adjust.m = "BY")

  # permutational dispersion
  disp_coi <- betadisper(dist_coi,interaction(COI_p$Day.Night,COI_p$Treatment))
  perm_disp_res <- permutest(disp_coi, pairwise = T ,permutations = how(nperm=999))
  perm_disp_res
  
  ## eDNA index
  dist_coi_idx <- COI_idx %>%
    t() %>% 
    vegdist(method = "bray")
  
  MDS_coi_idx <- dist_coi_idx %>%
    metaMDS(trymax = 1000)
  
  nMDS_plot <- COI_p %>% 
    bind_cols(MDS_coi_idx$points) %>% 
    group_by(Day.Night,Treatment) %>% 
    mutate(cx = mean(MDS1, na.rm = TRUE),
         cy = mean(MDS2, na.rm = TRUE))
  
  nMDS_plot %>%
    ggplot(aes(x = MDS1, y = MDS2, color = Day.Night, shape = Treatment)) +
    geom_segment(aes(xend = cx, yend = cy), alpha = 0.25, show.legend = FALSE) +
    stat_ellipse(aes(color = Day.Night),fill=NA,geom = "polygon", alpha = 0.20,  level = 0.75) +
    geom_point(size = 3) +
    geom_point(data = nMDS_plot %>% group_by(Day.Night,Treatment) %>% summarise(cx=first(cx),cy=first(cy)),
               aes(x = cx, y = cy, color = Day.Night),
               shape = 4, stroke = 2, size = 4, inherit.aes = FALSE) +
    theme_bw()
    
  # permanova
  res <- adonis2(as.matrix(dist_coi_index) ~ interaction(COI_p$Day.Night,COI_p$Treatment))
  res

  # posthoc
  pairwise.adonis2(dist_coi_index ~ MDS_coi_idx, data= COI_p %>% mutate(MDS_coi_idx=paste0(Day.Night,Treatment)), COI_p.adjust.m = "BY")

  # permutational dispersion
  disp_coi_idx <- betadisper(dist_coi_idx,interaction(COI_p$Day.Night,COI_p$Treatment))
  PERMDISP <- permutest(disp_coi_idx, pairwise = T ,permutations = how(nperm=999))
  PERMDISP
```

## Abstract

## Introduction